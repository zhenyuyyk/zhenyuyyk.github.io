# 垃圾回收机制
垃圾回收又称为 GC(Garbage Collecation)。编写 JavaScript 程序时，开发者不需要手工跟踪内存的使用情况，只要按照标准写 JavaScript 代码，JavaScript 程序运行所需内存的分配以及无用内存的回收完全是自动管理。JavaScript 中自动垃圾回收机制的原理为：
> 找出那些不再使用的变量，然后释放其占用的内存。
> 垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。

常用到的垃圾回收方式为：
* 引用计数
* 标记清除

## 一、内存

要想了解JavaScript的垃圾回收机制，必须要知道内存的概念。JavaScript中的内存分为栈内存与堆内存

* 基本类型值在内存中占固定大小的空间，因此被保存在**栈内存**中
* 引用类型值是对象，保存在**堆内存**中。包含引用类型值的变量实际包含并非对象本身，而是指向该对象的指针。一个变量从另一个变量复制引用类型的值时，复制的也是指向该对象的指针。

## 二、引用计数

这是最初级的垃圾收集算法，在IE9之前采用。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

```
function test () {
      var a = {} //  a的引用计数为 0,
      var b = a // a 被 b 引用 a引用计数为 1
      let c = a // a 被 c 引用 a引用计数为 2
      b = null // b 不再引用a a的引用计数减为 1
      c = null // c不再引用a a的引用计数减为 0 将被回收
}
```

### 引用计数缺陷

该算法有个最大的缺陷：无法处理循环引用。比如：

```
function problem(){
    var a = new Object();
    var b = new Object();
    a.test = b;
    b.test = a;
}
```

上面a,b互相引用,计数不会等于0,内存不会回收,重复调用,会占用大量内存。

## 三、标记-清除算法
此算法可以分为两个阶段，一个是标记阶段（mark），一个是清除阶段(sweep)。

1. **标记阶段**，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。
2. **清除阶段**，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。

简单来说就是：把所有活动对象做上标记,把没有标记（也就是非活动对象）销毁
![Image text](../styles/images/marksweep.gif)  

### 标记-清楚算法缺陷

* 那些无法从根对象查询到的对象都将被清除
* 垃圾收集后有可能会造成大量的内存碎片，像上面的图片所示，垃圾收集后内存中存在三个内存碎片，假设一个方格代表1个单位的内存，如果有一个对象需要占用3个内存单位的话，那么就会导致Mutator一直处于暂停状态，而Collector一直在尝试进行垃圾收集，直到Out of Memory。

### 常见的内存泄漏

Foo 被调用时, this 指向全局变量(window),相当于与是全局变量,变量不会被回收

```
function test() {
    this.test = "lala";
}
foo();
```

当节点被干掉,定时器还是会不停执行

```
setInterval(function() {
    var node = document.getElementById('div');
    if(node) {
        node.innerHTML = "!......."
    }
}, 5000); 
```

闭包

```
var add = (function () {
    var num = 0;
    return function () {
        return ++num;
    };
  })();
console.log(add());
console.log(add());
console.log(add());
```

## 四、JavaScript V8引擎的垃圾回收机制
