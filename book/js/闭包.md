<!-- TOC -->

- [闭包](#闭包)
    - [前置条件](#前置条件)
    - [什么是闭包](#什么是闭包)
    - [闭包的实际应用](#闭包的实际应用)
    - [使用闭包的注意点](#使用闭包的注意点)

<!-- /TOC -->
# 闭包

## 前置条件

想要理解闭包，你需要先知道变量的作用域

+ 全局作用域：在代码中任何地方都可以访问和修改，比如window、var a="xx"
+ 局部作用域：在函数内部定义的变量，作用域限制在函数内
+ 块级作用域：ES6增加，let和const，先声明后访问

## 什么是闭包

什么是闭包，你可能会搜出很多答案....

《JavaScript高级程序设计》这样描述：

> 闭包是指有权访问另一个函数作用域中的变量的函数；

《JavaScript权威指南》这样描述：

> 从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。

《你不知道的JavaScript》这样描述：

> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

其实三种概念是相通的，我们看下面的例子：

```
function foo() {
  let a = 10;
  function bar() {
    console.log(a); // 10
  }
  return bar;
}
let baz = foo();
baz();
```

这样就产生了闭包，为啥产生了闭包？

函数foo中创建了函数bar，并返回了函数bar，并在函数foo作用域外执行了函数bar，当函数bar执行时，访问了foo作用域中的变量a，这就产生了闭包。

这样也符合上面的三种描述

## 闭包的实际应用

我们看一个很经典的for循环中使用定时器延迟打印的问题：

```
for (var i = 1; i <= 10; i++) {
	setTimeout(function () {
		console.log(i);
	}, 1000);
}

```

在这段代码中，我们对其的预期是输出1~10，但却输出10次11。这是因为setTimeout是一个宏任务，当setTimeout执行的时候for循环已经结束了，所以打印出十次11

知道原因了，如何来解决呢?

我们可以让i在每次迭代的时候，都产生一个私有的作用域，在这个私有的作用域中保存当前i的值。

```
for (var i = 1; i <= 10; i++) {
	(function (j) {
		setTimeout(function () {
			console.log(j);
		}, 1000);
	})(i);
}
```

## 使用闭包的注意点

+ 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
+ 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。


