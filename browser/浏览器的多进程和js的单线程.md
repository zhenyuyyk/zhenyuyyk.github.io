# 进程、线程之间的关系

* 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
* 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
* 单线程与多线程，都是指在一个进程内的单和多

# 浏览器是多进程的

我在Chrome浏览器中打开了多个tab，然后打开mac中的活动监视器：
![Image text](../styles/images/duojincheng.png)
如上图，我们可以看到一个Chrome浏览器启动了好多个进程。
* 浏览器是多进程的
* 每一个Tab页，都是一个独立的进程

# 浏览器包含了哪些进程

1. 主进程
    * 协调控制其他子进程（创建，销毁）
    * 浏览器界面显示，用户交互，前进、后退、收藏
    * 将渲染进程得到的内存中的Bitmap，绘制到用户界面上
    * 处理不可见操作，网络请求，文件访问等
2. 第三方插件进程
    * 每种类型的插件对应一个进程，仅当使用该插件时才创建
3. GPU进程
    * 用于3D绘制等
4. 渲染进程，就是我们说的浏览器内核
    * 负责页面渲染，脚本执行，事件处理等
    * 每个tab页一个渲染进程
    
对于前端来说，最主要的是 **渲染进程**，也就是我们常说的浏览器内核

# 渲染进程
从前文我们得知，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。

而对于渲染进程来说，它当然也是多线程的了，接下来我们来看一下渲染进程包含哪些线程。

1. GUI渲染线程
    * 负责渲染页面，布局和绘制
    * 页面需要重绘和回流时，该线程就会执行
    * 与js引擎线程互斥，防止渲染结果不可预期
2. JS引擎线程
    * 负责处理解析和执行javascript脚本程序
    * 只有一个JS引擎线程（单线程）
    * 与GUI渲染线程互斥，防止渲染结果不可预期
3. 事件触发线程
    * 用来控制事件循环（鼠标点击、setTimeout、ajax等）
    * 当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中
4. 定时触发器线程
    * setInterval与setTimeout所在的线程
    * 定时任务并不是由JS引擎计时的，是由定时触发线程来计时的
    * 计时完毕后，通知事件触发线程
5. 异步http请求线程
    * 浏览器有一个单独的线程用于处理AJAX请求
    * 当请求完成时，若有回调函数，通知事件触发线程

# js的单线程

js的单线程和它的用途有关，作为浏览器脚本语言，它主要是用来处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。

如果JavaScript是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突；

如果Javascript是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。

当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript在最初就选择了单线程执行。

这也解释了为什么GUI线程和JS引擎是互斥的。

当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。

# Js的单线程是如何工作的

JS 引擎不是单独运行的 —— 它运行在一个宿主环境中，对于大多数开发者来说就是典型的浏览器和 Node.js。实际上，如今，JavaScript 被应用到了从机器人到灯泡的各种设备上。每个设备都代表了一种不同类型的 JS 引擎的宿主环境。

所有的环境都有一个共同点，就是都拥有一个事件循环(EventLoop)内置机制，它随着时间的推移每次都去调用 JS 引擎去处理程序中多个块的执行。

想要理解JS 引擎的机制，首先要理解三个定义：
* 栈(Stack)
> 是一种遵循后进先出(last in first out LIFO)原则的有序集合；在栈里，新元素都靠近栈顶，旧元素都靠近栈底(现实中栈的例子:一摞书或者堆放在一起的盘子)

* 队列(Queue)
> 是一种遵循先进先出(first in first out FIFO)原则的一组有序的项；在队列中，最新添加的元素必须排在队列的末尾(现实中队列的例子：排队过安检)

* 堆(Heap)
>  主要用于存放引用类型诸如object这类，存储的对象类型数据对于大小在这方面都是未知的。堆内存是动态分配内存，内存大小不一，也不会自动释放。


## 宏任务和微任务

* 常见的宏任务：script（整体代码）、setTimeout、setInterval、I/O、setImmedidate
* 常见的微任务：process.nextTick、MutationObserver、Promise.then catch finally

每次执行栈为空的时候，系统会优先处理微任务队列，处理完微任务队列里的所有任务，再去处理宏任务。

## 浏览器Event Loop执行方式

1. 顺序执行全局Script代码，遇到同步语句则执行，遇到异步语句则把它丢到宏队列或微队列。
> 如遇到console.log则正常执行;
> 遇到setTimeout则把他扔进宏队列;
> 遇到promise，则先正常执行promise里面语句，把后面的then回调函数扔进微队列
2. 全局Script代码执行完后，调用栈为空
3. 再从微队列取出位于队首代码或回调函数，放入调用栈中执行，此过程中如果产生新的微队列或宏队列函数则照常扔到队列末尾
> 如执行promise.then()
4. 重复取出微队列函数，直到微队列为空
5. 再从宏队列取出一个函数放入调用栈执行
6. 重复1~5直到宏队列为空

来看个例子：
```
console.log(1);

setTimeout(() => {
  console.log(2);
  Promise.resolve().then(() => {
    console.log(3)
  });
});//macrotask1

new Promise((resolve, reject) => {
  console.log(4)
  resolve(5)
}).then((data) => {
  console.log(data);
})

setTimeout(() => {
  console.log(6);
})//macrotask2

console.log(7);
```
1. 执行console.log(1)  输出1
2. setTimeout扔进宏队列，将这个记作macrotask1，此时宏队列为{macrotask1}
3. 同步执行promise内语句console.log(4)，输出4，后面的then扔进微队列，此时的微队列{console.log(5)}
4. 下一个setTimeout扔进宏队列，记作macrotask2，此时的宏队列{macrotask1,macrotask2}
5. 执行console.log(7) 输出7
6. 从微队列取出队首console.log(5)执行，输出5，此时微队列为{}
7. 由于微队列为空，于是从宏队列取出队首函数macrotask1，扔进调用栈执行，此时宏队列{macrotask2}
8. 执行macrotask1，执行console.log(2) 输出2，后面的Promise.resolve().then()扔进微队列，此时微队列{console.log(3)}
9. macrotask1执行完(调用栈空)，再去执行微队列{console.log(3)}，输出3，此时微队列{}
10. 微队列空，再从宏队列取出函数macrotask2，执行console.log(6)，输出6
11. 宏队列空，代码执行完毕

最终输出为1475236

如果上面的题目你还不清楚EventLoop的执行顺序，可以读一下这个大佬的文章

[来45道Promise面试题一次爽到底](https://juejin.im/post/6844904077537574919) 




















